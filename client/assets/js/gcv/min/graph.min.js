"use strict";/** The Graph namespace. */var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i["return"])_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError("Invalid attempt to destructure non-iterable instance")}}}();var _class3,_temp,_class5,_temp2;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}return call&&(typeof call==="object"||typeof call==="function")?call:self}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass)}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}var Graph=Graph||{};Graph.Graph=function(){function _class(edgeDelimiter){_classCallCheck(this,_class);// make the class effectively abstract
if(new.target===Graph.Graph){throw new TypeError("Cannot construct Graph instances directly")}this.checkStaticOverride("Node");this.checkOverride("removeNodeEdges");this.checkOverride("addEdge");this.checkOverride("updateEdge");this.checkOverride("removeEdge");this.checkOverride("getEdge");this.ed=edgeDelimiter||":";this.nodes={};this.edges={}}// primitive operations
_createClass(_class,[{key:"checkStaticOverride",value:function checkStaticOverride(attr){if(this.constructor[attr]===undefined){throw new TypeError(this.constructor.name+" must override static attribute: "+attr)}}},{key:"checkOverride",value:function checkOverride(attr){if(this[attr]===undefined){throw new TypeError(this.constructor.name+" must override attribute: "+attr)}}},{key:"addNode",value:function addNode(id,attr){if(!this.nodes.hasOwnProperty(id)){this.nodes[id]=new this.constructor.Node(attr)}return this.getNode(id)}},{key:"updateNode",value:function updateNode(id,attr){if(this.nodes.hasOwnProperty(id)){this.nodes[id]=attr}}},{key:"removeNode",value:function removeNode(id){if(this.nodes.hasOwnProperty(id)){this.removeNodeEdges(id);delete this.nodes[id]}}},{key:"getNode",value:function getNode(id){if(this.nodes.hasOwnProperty(id)){return this.nodes[id]}return null}}]);return _class}();Graph.Node=function(){function _class2(attr){_classCallCheck(this,_class2);// make the class effectively abstract
if(new.target===Graph.Node){throw new TypeError("Cannot construct Node instances directly")}this.attr=attr}return _class2}();Graph.Directed=(_temp=_class3=function(_Graph$Graph){_inherits(_class3,_Graph$Graph);function _class3(edgeDelimiter){_classCallCheck(this,_class3);var _this=_possibleConstructorReturn(this,(_class3.__proto__||Object.getPrototypeOf(_class3)).call(this,edgeDelimiter));_this.inNeighbors={};_this.outNeighbors={};return _this}_createClass(_class3,[{key:"getEdgeId",// primitive operations
value:function getEdgeId(u,v){return u<v?u+this.ed+v:v+this.ed+u}},{key:"addEdge",value:function addEdge(u,v,attr){var e=this.getEdgeId(u,v);if(!this.edges.hasOwnProperty(e)){this.nodes[u].neighbors.add(v);this.nodes[v].neighbors.add(u);this.edges[e]=attr}}},{key:"updateEdge",value:function updateEdge(u,v,attr){var e=this.getEdgeId(u,v);if(this.edges.hasOwnProperty(e)){this.edges[e]=attr}}},{key:"removeEdge",value:function removeEdge(u,v){var e=this.getEdgeId(u,v);if(this.edges.hasOwnProperty(e)){delete this.edges[e];this.nodes[u].neighbors.delete(v);this.nodes[v].neighbors.delete(u)}}},{key:"getEdge",value:function getEdge(u,v){var e=this.getEdgeId(u,v);if(this.edges.hasOwnProperty(e)){return this.edges[e]}return null}}]);return _class3}(Graph.Graph),_class3.Node=function(_Graph$Node){_inherits(_class4,_Graph$Node);function _class4(attr){_classCallCheck(this,_class4);var _this2=_possibleConstructorReturn(this,(_class4.__proto__||Object.getPrototypeOf(_class4)).call(this,att));_this2.inNeighbors=new Set;_this2.outNeighbors=new Set;return _this2}return _class4}(Graph.Node),_temp);Graph.Undirected=(_temp2=_class5=function(_Graph$Graph2){_inherits(_class5,_Graph$Graph2);function _class5(edgeDelimiter){_classCallCheck(this,_class5);return _possibleConstructorReturn(this,(_class5.__proto__||Object.getPrototypeOf(_class5)).call(this,edgeDelimiter))}_createClass(_class5,[{key:"removeNodeEdges",// primitive operations
value:function removeNodeEdges(id){var _this4=this;this.nodes[id].neighbors.forEach(function(v){_this4.removeEdge(id,v)})}},{key:"getEdgeId",value:function getEdgeId(u,v){return u<v?u+this.ed+v:v+this.ed+u}},{key:"addEdge",value:function addEdge(u,v,attr){var e=this.getEdgeId(u,v);if(!this.edges.hasOwnProperty(e)){this.nodes[u].neighbors.add(v);this.nodes[v].neighbors.add(u);this.edges[e]=attr}}},{key:"updateEdge",value:function updateEdge(u,v,attr){var e=this.getEdgeId(u,v);if(this.edges.hasOwnProperty(e)){this.edges[e]=attr}}},{key:"removeEdge",value:function removeEdge(u,v){var e=this.getEdgeId(u,v);if(this.edges.hasOwnProperty(e)){delete this.edges[e];this.nodes[u].neighbors.delete(v);this.nodes[v].neighbors.delete(u)}}},{key:"getEdge",value:function getEdge(u,v){var e=this.getEdgeId(u,v);if(this.edges.hasOwnProperty(e)){return this.edges[e]}return null}// additional operations
/**
    * Contracts the given edge into a single vertex, reusing the smaller ID.
    * @param {id} u - First node of the edge.
    * @param {id} v - Second node of the edge.
    * @param {function} [contractF=function(uAttr, vAttr, eAttr) { return
    * undefined }]] - Computes the attr of the merged vertices.
    * @param {function} [updateF=function(contractF(...), wAttr, eAttr) { return
    * undefined }] - How to update the attr of affected edges.
    */},{key:"contractEdge",value:function contractEdge(u,v,contractF,updateF){var _this5=this;var e=this.getEdge(u,v);if(e!=null){var _ref=u<v?[u,v]:[v,u],_ref2=_slicedToArray(_ref,2),keep=_ref2[0],remove=_ref2[1],keepNode=this.getNode(keep),removeNode=this.getNode(remove);keepNode.attr=contractF(keepNode.attr,removeNode.attr,e);// update "keep" edges
keepNode.neighbors.forEach(function(w){if(w!=remove){var wAttr=_this5.getNode(w).attr,eAttr=_this5.getEdge(keep,w),attr=updateF(keepNode.attr,wAttr,eAttr);_this5.updateEdge(keep,w,attr)}});// replace "remove" edges
removeNode.neighbors.forEach(function(w){if(w!=keep&&_this5.getEdge(keep,w)==null){var wAttr=_this5.getNode(w).attr,eAttr=_this5.getEdge(remove,w),attr=updateF(keepNode.attr,wAttr,eAttr);_this5.addEdge(keep,w,attr)}});this.removeNode(remove)}}}]);return _class5}(Graph.Graph),_class5.Node=function(_Graph$Node2){_inherits(_class6,_Graph$Node2);function _class6(attr){_classCallCheck(this,_class6);var _this6=_possibleConstructorReturn(this,(_class6.__proto__||Object.getPrototypeOf(_class6)).call(this,attr));_this6.neighbors=new Set;return _this6}return _class6}(Graph.Node),_temp2);Graph.FR=function(){function _class7(nodes){_classCallCheck(this,_class7);this.nodes=nodes||[];this.descendants=[];this.paths={};this.intervals={};this.supporting={}}_createClass(_class7,[{key:"addToPath",value:function addToPath(pId,n,kappa){if(!this.paths.hasOwnProperty(pId)){this.paths[pId]=[]}this.paths[pId].push(n);if(!this.intervals.hasOwnProperty(pId)){this.intervals[pId]=[]}var halfKappa=kappa/2;// (begin, end, nodes spanned)
this.intervals[pId].push([n-halfKappa,n+halfKappa,1])}},{key:"mergeIntervals",value:function mergeIntervals(hardSpan){var comparePoints=function comparePoints(a,b){var _a=_slicedToArray(a,3),ap=_a[0],ac=_a[1],as=_a[2],_b=_slicedToArray(b,3),bp=_b[0],bc=_b[1],bs=_b[2];if(ap<bp||ap==bp&&ac>bc){return-1}else if(bp<ap||bp==ap&&bc>ac){return 1}return 0};for(var pId in this.intervals){if(this.intervals.hasOwnProperty(pId)){var points=[];for(var i=0;i<this.intervals[pId].length;i++){var _intervals$pId$i=_slicedToArray(this.intervals[pId][i],3),begin=_intervals$pId$i[0],end=_intervals$pId$i[1],span=_intervals$pId$i[2];points.push([begin,1,span]);points.push([end,-1,0])}points.sort(comparePoints);var combinedIntervals=[],counter=0,begin=0,span=0;for(var i=0;i<points.length;i++){var _points$i=_slicedToArray(points[i],3),p=_points$i[0],c=_points$i[1],s=_points$i[2];if(counter==0){begin=p;span=0}counter+=c;span+=s;if(counter==0){combinedIntervals.push([begin,p,hardSpan||span])}}this.intervals[pId]=combinedIntervals}}}},{key:"computeSupport",value:function computeSupport(alpha,hardSpan){this.mergeIntervals(hardSpan);this.supporting=[];for(var pId in this.intervals){if(this.intervals.hasOwnProperty(pId)){for(var i=0;i<this.intervals[pId].length;i++){if(this.intervals[pId][i][2]/this.nodes.length>=alpha){this.supporting.push(pId);break}}}}}},{key:"merge",value:function merge(other){var fr=new Graph.FR;fr.nodes=this.nodes.concat(other.nodes);fr.descendants=[this,other];fr.paths=Object.assign({},this.paths);fr.intervals=Object.assign({},this.intervals);for(var id in other.paths){if(fr.paths.hasOwnProperty(id)){fr.paths[id]=fr.paths[id].concat(other.paths[id])}else{fr.paths[id]=other.paths[id].slice()}}for(var id in other.intervals){if(fr.intervals.hasOwnProperty(id)){fr.intervals[id]=fr.intervals[id].concat(other.intervals[id])}else{fr.intervals[id]=other.intervals[id].slice()}}return fr}}]);return _class7}();/**
  * The Frequented Regions Algorithm.
  * @param {object} tracks - GCV track data.
  * @param {number} alpha - Fraction of region nodes a supporting path must
  * traverse.
  * @param {number} kappa - Maximum insertion size.
  * @param {number} minsup - Minimum number of paths that must support of region
  * for it to be considered frequent.
  * @param {number} minsize - Minimum size (number of nodes) of a region to be
  * considered frequent.
  * @return {int} - The computed score.
  */Graph.frequentedRegions=function(tracks,alpha,kappa,minsup,minsize,options){var omit=options.omit||[];var contractF=function contractF(uFR,vFR,eFR){return eFR};var updateF=function updateF(uFR,vFR,eFR){var fr=uFR.merge(vFR);fr.computeSupport(alpha);return fr};var findFRs=function findFRs(root,minsup,minsize,prevsup){var frs=[];var sup=prevsup;if(root.nodes.length>=minsize&&root.supporting.length>=minsup&&root.supporting.length>prevsup){frs.push(root);sup=root.supporting.length}if(root.descendants.length>0){root.descendants=findFRs(root.descendants[0],minsup,minsize,sup).concat(findFRs(root.descendants[1],minsup,minsize,sup))}if(frs.length>0){return frs}return root.descendants};// build a gene family FR graph
var g=new Graph.Undirected;// add nodes with FRs as attributes
for(var i=0;i<tracks["groups"].length;i++){for(var j=0;j<tracks["groups"][i]["genes"].length;j++){var id=tracks["groups"][i]["genes"][j]["family"];if(omit.indexOf(id)==-1){var n=g.getNode(id);if(n==null){n=g.addNode(id,new Graph.FR([id]))}n.attr.addToPath(i,j,kappa)}}}for(var id in g.nodes){g.nodes[id].attr.computeSupport(alpha,1)}// add edges with FRs resulting from contraction as attributes
for(var i=0;i<tracks["groups"].length;i++){for(var j=0;j<tracks["groups"][i]["genes"].length-1;j++){var id=tracks["groups"][i]["genes"][j]["family"],n=g.getNode(id),id2=tracks["groups"][i]["genes"][j+1]["family"],n2=g.getNode(id2);if(g.getEdge(id,id2)==null&&id!=id2&&// TODO: handle copies!
omit.indexOf(id)==-1&&omit.indexOf(id2)==-1){g.addEdge(id,id2,updateF(n.attr,n2.attr))}}}// iteratively contract edges in most support first order
var fr=null;console.log("num nodes: "+Object.keys(g.nodes).length);console.log("num edges: "+Object.keys(g.edges).length);while(Object.keys(g.edges).length>1){// find max edge weight
var maxFR=null,maxE=null;for(var e in g.edges){if(g.edges.hasOwnProperty(e)&&(maxFR==null||maxFR.supporting.length<g.edges[e].supporting.length)){maxFR=g.edges[e];maxE=e}}fr=maxFR;var _maxE$split=maxE.split(g.ed),_maxE$split2=_slicedToArray(_maxE$split,2),u=_maxE$split2[0],v=_maxE$split2[1];// contract edge
g.contractEdge(u,v,contractF,updateF)}// return interesting FRs identified by traversing hierarchy
return fr!==null?findFRs(fr,minsup,minsize,0):[]};

