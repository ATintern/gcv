'use strict';/** The Genomic Context Viewer namespace. */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var GCV=GCV||{};/** The legend viewer. */GCV.Legend=function(){_createClass(_class2,[{key:'_autoResize',/**
    * Adds a hidden iframe that calls the given resize event whenever its width
    * changes.
    * @param {string} el - The element to add the iframe to.
    * @param {function} f - The function to call when a resize event occurs.
    * @return {object} - The hidden iframe.
    */// Private
// Constants
value:function _autoResize(el,f){var iframe=document.createElement('IFRAME');iframe.setAttribute('allowtransparency',true);iframe.className='GCV-resizer';el.appendChild(iframe);iframe.contentWindow.onresize=function(){clearTimeout(this.resizeTimer);this.resizeTimer=setTimeout(f,10)};return iframe}/**
    * Fades everything in the view besides the given selection.
    * @param {object} selection - What's omitted from the fade.
    */},{key:'_beginHover',value:function _beginHover(selection){clearTimeout(this._beginHoverTimeout);this._beginHoverTimeout=setTimeout(function(){d3.selectAll('.GCV').classed('hovering',true);selection.classed('active',true)},this.options.hoverDelay)}/**
    * Unfades everything in the view and revokes the selection's omission from
    * being faded.
    * @param {object} selection - What's no longer omitted.
    */},{key:'_endHover',value:function _endHover(selection){selection.classed('active',false);// delay unfading for smoother mouse dragging
clearTimeout(this._beginHoverTimeout);clearTimeout(this._hoverTimeout);this._hoverTimeout=setTimeout(function(){clearTimeout(this._hoverTimeout);this._hoverTimeout=undefined;// make sure nothing is being hovered
if(d3.selectAll('.GCV .active').empty()){d3.selectAll('.GCV').classed('hovering',false)}},125)}/** Resizes the viewer and x scale. Will be decorated by other components. */},{key:'_resize',value:function _resize(){// viewer
var w=this.container.clientWidth;this.viewer.attr('width',w)}/**
    * Decorates the _resize function with the given function.
    * @param {function} d - The decorator function.
    */},{key:'_decorateResize',value:function _decorateResize(d){this._resize=function(resize){resize();d()}.bind(this,this._resize)}/**
    * Parses parameters and initializes variables.
    * @param {HTMLElement|string} el - ID of or the element itself where the
    * viewer will be drawn in.
    * @param {object} colors - D3 family-to-color map.
    * @param {object} data - A list of objects with name and id attributes.
    * @param {object} options - Optional parameters.
    */},{key:'_init',value:function _init(el,colors,data,options){var _this=this;// parse positional parameters
if(el instanceof HTMLElement)this.container=el;else this.container=document.getElementById(el);if(this.container===null){throw new Error('"'+el+'" is not a valid element/ID')}this.colors=colors;if(this.colors===undefined){throw new Error('"color" is undefined')}if(data===undefined){throw new Error('"data" is undefined')}this.data=JSON.parse(JSON.stringify(data));// create the viewer
this.viewer=d3.select(this.container).append('svg').attr('class','GCV');// create the scales used to plot genes
// parse optional parameters
this.options=Object.assign({},options);this.options.highlight=this.options.highlight||[];this.options.selectiveColoring=this.options.selectiveColoring;this.options.familyClick=this.options.familyClick||function(family){};this.options.autoResize=this.options.autoResize||false;this.options.hoverDelay=this.options.hoverDelay||0;if(this.options.contextmenu)this.viewer.on('contextmenu',function(){_this.options.contextmenu(d3.event)});if(this.options.click)this.viewer.on('click',function(){_this.options.click(d3.event)});// make sure resize always has the right context
this._resize=this._resize.bind(this);// initialize the viewer width/height and scale range
this._resize()}/**
    * Draws the legend key for the given family.
    * @param {object} legend - D3 selection of the legend to add the key to.
    * @param {object} f - The family for which a key is to be drawn.
    * @return {object} - D3 selection of the key.
    */},{key:'_drawKey',value:function _drawKey(legend,f){var _this2=this;var obj=this;// create the key group
var key=legend.append('g').attr('class','legend').attr('data-family',f.id).style('cursor','pointer').on('mouseover',function(){var selection=d3.selectAll('.GCV [data-family="'+f.id+'"]');obj._beginHover(selection)}).on('mouseout',function(){var selection=d3.selectAll('.GCV [data-family="'+f.id+'"]');obj._endHover(selection)}).on('click',function(){_this2.options.familyClick(f)});// add the colored rectangles
var rect=key.append('rect').attr('width',this._RECT_SIZE).attr('height',this._RECT_SIZE).style('fill',function(){return _this2.colors(f.id)}).attr('class',function(){if(_this2.options.highlight.indexOf(f.name)!==-1)return'focus';return''});// add then labels
var text=key.append('text').style('text-anchor','end').style('dominant-baseline','middle').attr('y',function(){return _this2._RECT_SIZE/2}).text(function(){return f.name});// implement the resize function
key.resize=function(rect,text){var w=this.viewer.attr('width'),x=w-(this._PAD+this._RECT_SIZE);rect.attr('x',x);x-=2*this._PAD;text.attr('x',x)}.bind(this,rect,text);key.resize();return key}/**
    * Creates a legend containing keys for the familyName families.
    * @return {object} - D3 selection of a group containing the keys.
    */},{key:'_drawLegend',value:function _drawLegend(){var _this3=this;var legend=this.viewer.append('g');// create the legend keys
var data=this.data.filter(function(f){if(_this3.options.selectiveColoring!==undefined)return _this3.options.selectiveColoring[f.id]>1;return true});legend.keys=[];data.forEach(function(f,i){var k=_this3._drawKey(legend,f),y=legend.node().getBBox().height;if(i>0)y+=2*_this3._PAD;k.attr('transform','translate(0, '+y+')');legend.keys.push(k)});// implement the resize function
legend.resize=function(keys){keys.forEach(function(k){k.resize()})}.bind(this,legend.keys);return legend}/** Draws the viewer. */},{key:'_draw',value:function _draw(){var _this4=this;// draw the legend
var legend=this._drawLegend();legend.attr('y',this._PAD);this._decorateResize(legend.resize);var lBox=legend.node().getBBox();this.viewer.attr('height',lBox.y+lBox.height+2*this._PAD);// create an auto resize iframe, if necessary
if(this.options.autoResize){this.resizer=this._autoResize(this.container,function(e){_this4._resize()})}}// Public
/**
    * The constructor.
    * @param {HTMLElement|string} el - ID of or the element itself where the
    * viewer will be drawn in.
    * @param {object} colors - D3 family-to-color map.
    * @param {object} data - The data the viewer will visualize.
    * @param {object} options - Optional parameters.
    */}]);function _class2(el,colors,data,options){_classCallCheck(this,_class2);this._PAD=2;this._RECT_SIZE=18;this._hoverTimeout=0;this._init(el,colors,data,options);this._draw()}/** Makes a copy of the SVG and inlines external GCV styles. */_createClass(_class2,[{key:'_inlineCopy',value:function _inlineCopy(){// clone the current view node
var clone=d3.select(this.viewer.node().cloneNode(true));// load the external styles
var sheets=document.styleSheets;// inline GCV styles
for(var i=0;i<sheets.length;i++){var rules=sheets[i].rules||sheets[i].cssRules;for(var r in rules){var rule=rules[r],selector=rule.selectorText;if(selector!==undefined&&selector.startsWith('.GCV')){var style=rule.style,selection=clone.selectAll(selector);for(var k=0;k<style.length;k++){var prop=style[k];selection.style(prop,style[prop])}}}}return clone}/** Generates the raw SVG xml. */},{key:'xml',value:function xml(){try{var isFileSaverSupported=!!new Blob}catch(e){alert('Your broswer does not support saving')}// create a clone of the viewer with all GCV styles inlined
var clone=this._inlineCopy();// generate the data
var xml=new XMLSerializer().serializeToString(clone.node());return xml}/** Manually destroys the viewer. */},{key:'destroy',value:function destroy(){if(this.resizer){if(this.resizer.contentWindow)this.resizer.contentWindow.onresize=undefined;this.container.removeChild(this.resizer)}this.container.removeChild(this.viewer.node());this.container=this.viewer=this.resizer=undefined}}]);return _class2}();

